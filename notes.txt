unit tests test the smallest unit
in java for example, that can be a method

Notice also, that the package for the tests and source code is the same

Conventions:
when testing a class, the test name would be the class name followed by test, for example:

class BMICalculatorTest {

    @Test
    void test() {
        assertTrue(BMICalculator.isDietRecommended(81.2, 1.65));
    }
}

another convention is "should/when", for example:
should_ReturnTrue_When_dietRecommended
another why to write this would be: shouldReturnTrue_whenDietRecommended

Given/When/Then: Arrange/Act/Assert => make the test as clear as possible, for example:
class BMICalculatorTest {

    @Test
    void should_ReturnTrue_when_DietRecommended() {
        // given
        double height = 1.65;
        double weight = 81.2;
        // when
        boolean recommended = BMICalculator.isDietRecommended(81.2, 1.65);
        // then
        assertTrue(recommended);
    }
}

High test coverage is a good thing, add as much as you can

Adding tests for exceptions is also recommended, look at the method's body or signature ins case it specifies a case where an exception can ve thrown
In this case, when can not write the test in the normal way, as the exception will be thrown and the code will break
so we need somthing is potentially executable. We need to store the result in a "Executable" variable
Use the object from the JUnit Lib "import org.junit.jupiter.api.function.Executable;"
On the left hand side, we need a lambda expression, we can easily acheive that by addint "() -> " in front of the call

for example:
@Test
void should_ThrowArithmeticException_when_HeightZero() {
    // given
    double height = 0.0;
    double weight = 81.2;
    // when
    Executable executable = () -> BMICalculator.isDietRecommended(weight, height);
    // then
    assertThrows(ArithmeticException.class, executable);
}

What does this mean? it means that now we have an executable, i.e when line "Executable executable = () -> BMICalculator.isDietRecommended(weight, height);" is reached, the code will not execute immediatley, instead it is executed inside the assert statement when the exception gets caught and asserted on

In case we have multiple assertions, if the 1st one fails, the 2nd one will never be executed,
so we use assertAll(). It takes executables as arguments. So all we have to do is wrap our asserts as lambdas
assertAll(
    () -> assertEquals(1.83, coderWorstBMI.getHeight()),
    () -> assertEquals(98.4, coderWorstBMI.getWeight())
);

for asserting on nulls, use assertNull

Assert on Arrays
----------------
when comparing array values, use assertArrayEquals which compares the values
assertEquals will check if the array references are the same
NOTE: assertArrayEquals will stop the comparision at the 1st failure

beforeAll / beforeEach and afterAll / afterEach hooks
-----------------------------------------------
in case we need to init some object, we do it in beforeEach
this recreates the object before every test
because we want the tests to be independant of each other, especially if the objects created are mutable

IMPORTANT: beforeAll and afterAll must be "static"
we reserve these for ops that are too expensive to run every time like setting up a DB connection for example

When comparing Objects 
----------------------
void should_ReturnCorrectDietPlan_when_CorrectCoder() {
    Coder coder = new Coder(1.82, 75.0, 26, Gender.MALE);
    DietPlan expected = new DietPlan(2202, 110, 73, 275);

    DietPlan actual = dietPlanner.calculateDiet(coder);

    // assertEquals(); does not work, it will compare the obj references
    assertAll(
            () -> assertEquals(expected.getCalories(), actual.getCalories()),
            () -> assertEquals(expected.getCarbohydrate(), actual.getCarbohydrate()),
            () -> assertEquals(expected.getProtein(), actual.getProtein()),
            () -> assertEquals(expected.getFat(), actual.getFat())
    );
}

Parametrized Source Data
------------------------
@ParameterizedTest
@ValueSource(doubles = {70.0, 89.0, 95.0, 110.0})
void should_ReturnTrue_when_DietRecommendedParametrized(double coderWeight) {
    // given
    double height = 1.65;
    double weight = coderWeight;
    // when
    boolean recommended = BMICalculator.isDietRecommended(weight, height);
    // then
    assertTrue(recommended);
}
=> the values are injected into the function parameter automatically

When providing multiple values, we use CsvSource
Here, the variable name is reserved to "value", we can use another, but we can omit it
@ParameterizedTest(name = "weight={0} height={1}") => this is not needed, but it makes the output more friendly
@CsvSource(value = {"70.0, 1.72", "89.0, 1.75", "95.0, 1.78"})
void should_ReturnTrue_when_DietRecommendedParametrized(double coderWeight, double coderHeight)

In case we want to use an actual CSV file, then:
@CsvFileSource(resources = "/diet-recommended-input-data.csv",  numLinesToSkip = 1)
numLinesToSkip => we use this to skip some lines in case, for example, the 1st line has column/header names, i.e no actual test values. We can skip more than 1 line

CsvFileSource => will automatically start looking in src/test/resources folder, so all we have to do
it start with a slash and make sure to get the file path and name right from there
the rest is the same as if using CsvSource

Repeated tests 
--------------
instead of @Test, we can use @RepeatedTest(x)
where x is the number of times we want a test to repeat @RepeatedTest(10), will repeat the test 10 times
each repeated test will be treated as a separate tests, so beforeEach and afterEach will execute 10 times as well

we can also add more configs to out annotations, for example:
@RepeatedTest(value = 10, name = RepeatedTest.LONG_DISPLAY_NAME)
this will make the output show the full function name for example
here "RepeatedTest" referes to the function being executed itself

Performance Tests
-----------------
for example, we want to check if a function executes in a certain time limit
@Test
void should_ReturnCoderWithWorstBMI_when_CodeListNotEmpty_in1ms() {
    // given
    List<Coder> coders = new ArrayList<>();
    for (int i = 0; i< 10000; i++) {
        coders.add(new Coder(1.0 + i,10.0 + i));
    }

    // when
    Executable coderWorstBMIExecutable = () -> BMICalculator.findCoderWithWorstBMI(coders);

    // then
    assertTimeout(Duration.ofMillis(1), coderWorstBMIExecutable);
}

Here we use assertTimeout and we wrap the function we want to assese in a lambda
only the execution time of the lambda is checked

org.opentest4j.AssertionFailedError: execution exceeded timeout of 1 ms by 2 ms => this means that the executable to took (1 + 2) = 3 seconds to execute

Assumptions 
-----------
assumeTrue(...) if some condition fails, then the test will be skipped instead of being failed
this can be usefull in case we want to only run a test in "staging" environment instead of "dev" for
so we check if some variable is == to "staging".

But this is not the best way, as we would like test test not to run in the 1st place 

another good use here is in case we are guarding again some exception. in case an exception was thrown
we catch in an assume (via the hole executable method we used before) and skip the test instead of failing it

Netsing
-------
this helps better organise the tests. It is applied on inner classes of test classes:

@Nested
class IsDietRecommnededTests {
    // put the tests methods here
}

=> this will also organise the output and nest the results and group them under the inner class name

In JUnit 5, a @Nested test class can access fields, methods, and setup from the outer test class â€” as long as the outer class is not static, which JUnit 5 already enforces. So if I have some variable (even if private var) defined in the outer test class, I can access it in the inner class the normal way

you can nest as much as you want.
Also, each inner class can have its own beforeEach and afterEach methods, refer to junit docs for more details

Other annotations
-----------------
@DisplayName("Some test name") => changes the display name of the test in the output report
I can also use it on nested InnerClasses

@Disabled => skips the tagged test. this will show up in the final report

@DisableOnOs(OS.WINDOWS) => will disable the test on widows but runs it on everything else