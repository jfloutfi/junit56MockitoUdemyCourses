An important aspect of mocking is that it allows us to mock dependencies such that, if we are testing a class, the tests will fail only if the class under testing has issues making said tests independant from any failures related to the dependencies themselves

in order to mock a class:
we declare a variable:
private MyService myService;

then, in a beforeEach tagged method, we instantiate a mock:
this.myService = mock(MyService.class)

the instance myService behaves like the real class when trying to access its memeber variables and methods, but behind the scenes, it does not have the real logic of the actual service class

Default return values
---------------------
Say we want to test a method that calls another method
that method belongs to a mocked object that is passed as an argument to the method under test
In this case, mockito uses "nice mocks", i.e it will return values that make sense, for example, same the mocked object has a method that return a List<Room>, then "nice mocks" will return an empty List<Room> (even if the list is empty, it is still of type List<Room>, so it will not break the code)

nice mocks for example, returns:
- empty lists
- 0
- null
- empty string
- ...

i.e it conserves the return type and returns a value that allows the rest of the code to execute

Custom return values
--------------------
Mocking method:

when(this.roomService.getAvailableRooms())
    .thenReturn(Collections.singletonList(new Room("1", 2)));

basically we are telling the mocked calss instance that when getAvailableRooms() is called, return the value we desire

Multiple thenReturn() calls
---------------------------
We can make the thenReturn() method return different values when it is called multiple times.

We do than by simply chaining multiple thenReturn()

when(this.roomService.getAvailableRooms())
  .thenReturn(rooms)
  .thenReturn(Collections.emptyList());

assertAll is usefull here as it will allow us to check all possible cases and get a detailed output of which check failed

Throwing Exceptions 
-------------------
when(this.roomService.findAvailableRoomId(bookingRequest))
  .thenThrow(BusinessException.class);

Then to check for the exception, we need to pack the call into an executable:
Executable executable = () -> this.bookingService.makeBooking(bookingRequest);
assertThrows(BusinessException.class, executable);

Argument Matcher
----------------
when(this.roomService.findAvailableRoomId(bookingRequest))
  .thenThrow(BusinessException.class);

=> digging deeper into the above, it means that the exception will be thrown when and only when "this=>bookingRequest" object is passed to it, i.e, if I had a 2nd instance "bookingRequest2", if I passe it to the findAvailableRoomId() method, the exception will not be thrown, instead, if nothing is define, the "nice mocks" will take place

What if we want to throw an exception or return a certain value no matter what bookingRequest instance is passed?

when(this.paymentService.pay(any(), anyDouble())).thenThrow(BusinessException.class);

We can use any() for objects, but we will have to specify which "any" for primitive types, like doubles or ints: anyDouble()

NOTE: for any(), we can also pass it the class of the object that can be passed to retsrict it a bit: any(BookingRequest.class)

IMPORTANT: matchers and exact values can not mix:
when(this.paymentService.pay(any(), 400.0)).thenThrow(BusinessException.class); => this will result in an error 
However, Mockito does provide a way around: eq() method
when(this.paymentService.pay(any(), eq(400.0))).thenThrow(BusinessException.class);

Matching strings is a bit trickier:
anyString() will not match nullable strings, so if the method was passed a null as its string value, the matcher will fail, here we need to use any() like any other object

Verifying behavior
------------------
Examples:
- we want to know how many times a method is called
- we want to know if a method inside the method under test was called
- we want to know if a certain variable inside the method under test was set
- ...
these are what we call the side effects of the method under test

so we use the verify methods:

verify(this.paymentService, times(1)).pay(bookingRequest, 400.0);
=> this will verify that the pay() method was called with the bookingRequest instance that was passed and the value 400.0 ONLY ONCE. Note that we are not passing the value 400.0 to the pay method here, this will be calculated by the pay method

verifyNoMoreInteractions(this.paymentService); => this will verify that after pay() was called, no other method of paymentService was called

In case we want to check that a method was never invoked, then:
verify(this.paymentService, never()).pay(any(), anyDouble());

Spy()
-----
using spy() instead of mock() ?

mocks have no logic, if nothing is specified, "nice mocks" are used

spies on the other hand have all the logic of the original class we are spying on unless we specify a different behavior => i.e we are dealing with partial mocks

spies are needed in case we want to use "verify" methods

Since spies use the real logic, sometimes we will need to create mocks to method that are called by the method under test, for example:

// Given
BookingRequest bookingRequest = new BookingRequest("1", LocalDate.of(2020, 01, 01), LocalDate.of(2020, 01, 05), 2, true);
bookingRequest.setRoomId("1.3");
String bookingId = "1";

// When
this.bookingService.cancelBooking(bookingId);
=> the above line will cause an exception because the cancelBooking method will actually try to get the real booking request using an ID that does not exist. this will result in a null (a get method in bookingDAO class fetches the booking request), the code in cancelBooking will then try to do an operation on said null which will throw a NullPointerException

So we use: doReturn
doReturn(bookingRequest).when(bookingDAO).get(bookingId);
=> bookingDAO has a get method that fetches the booking request using a given booking ID. it is this method that ends up returning the null. here, we are telling it, that, in case I am passing bookingId = "1" even if the booking ID does not exist in the list of booking, return the bookingRequest instance we created

Basically, what we are doing here, is elliminiating (mocking) a dependency that the cancelBooking() method uses

doThrow can be used for spies to throw exceptions - check example in voind mocking below

Mocking Void methods 
--------------------
=> mokcing methods that do not return anything

in case we want to mock a void method and have it throw an exception, we can not us when(), the compiler will show an error, in this case, we use doThrow() like the example below

doThrow(BusinessException.class).when(this.mailSender).sendBookingConfirmation(any());

in case, we do not want to throw any exception, but we still want to mock the sendBookingConfirmation method, we use doNothing()
doNothing().when(this.mailSender).sendBookingConfirmation(any());

to check that an exception was not thrown, we have 2 method:
- assert on nothing => if an exception is thrown, the test will fail
- assertDoesNotThrow(() -> this.bookingService.makeBooking(bookingRequest)); => more idiomatic and:
  - Makes intent explicit in test reports.
  - Useful when chaining with other assertions.
  - Works well when returning a value you want to assert on.

NOTE:
- doNothing should be usable with spies as well
- the "nice mocks" default behavior of void method (when using mock() and not spy()) is doNothing